from fastapi import FastAPI, Request
from slowapi import Limiter
from datetime import datetime


testsite = FastAPI(title="Test Site")

async def default_response(request: Request):
    """Creates a standard diagnostic response that includes information about the endpoint hit and the data sent.
    Also includes timestamps indicating the point at which the request was received and filled. This can be used
    to compare against the actual request and response time on the client side.

    Args:
        request (Request): Request object generated by hitting endpoint

    Returns:
        dict: Standard diagnostic response
    """
    
    
    response = {        
        "request": {
            "path": request["path"],
            "headers": request.headers,
            "queryParams": request.query_params,
            "clientAddress": request.client,
            "requestBody": await request.body(),            
        },
        "receivedAt": request.state.receivedAt,
        "fulfilledAt": datetime.now()
    }        
    
    return response
        
    
@testsite.get("/")
@testsite.post("/")
async def index(request: Request):    
    """Standard endpoint for non-rate-limited testing.

    Returns:
        dict: Standard diagnostic response
    """
    request.state.receivedAt = datetime.now()
    response = await default_response(request)
    
    return response


@testsite.get("/limited")
@testsite.post("/limited")
async def limited_endpoint(request: Request,
    rate: int = 10, period: str = "seconds", maxconcur: int = 10, delaysub: float = 0.0, maxrandomdelay: float = 0.0
    ):
    """Endpoint to hit to test BADGER's ability to handle different API limits.
    
    Supports following limits:
        - # of requests per defined period
        - max # of concurrent requests
        - minimum required delay in seconds between subsequent requests
        - add a randomized delay up to a maximum of seconds before providing a response
    
    Args:
        rate (int, optional): _description_. Defaults to 10.
        period (str, optional): _description_. Defaults to "seconds".
        maxconcur (int, optional): _description_. Defaults to 10.
        delaysub (float, optional): _description_. Defaults to 0.0.
        maxrandomdelay (float, optional): _description_. Defaults to 0.0.

    Returns:
        dict: Standard diagnostic response
    """
    
    # TODO: is delaysub incompatible with concurrency? if so, figure out how to handle (different endpoint?)
    # TODO: rate and period need to be both present - how do we handle that?
    # TODO: if rate limited rejects the request, how does that work with response?
    
    receivedAt = datetime.now()
    
    # TODO: implement delays
    
    response = await default_response(request, receivedAt)
    
    return response


